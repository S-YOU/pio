# encoding: utf-8

require 'pio/features'

describe Pio::Features do
  describe '.read' do
    context 'with a Features Request message' do
      Given(:features_request_dump) { [1, 5, 0, 8, 0, 0, 0, 0].pack('C*') }

      When(:features_request) { Pio::Features.read(features_request_dump) }

      Then { features_request.class == Pio::Features::Request }
      Then { features_request.ofp_version == 1 }
      Then do
        features_request.message_type ==
          Pio::OpenFlow::Type::FEATURES_REQUEST
      end
      Then { features_request.message_length == 8 }
      Then { features_request.transaction_id == 0 }
      Then { features_request.xid == 0 }
      Then { features_request.body.empty? }
    end

    context 'with a Features Reply message' do
      Given(:features_reply_dump) do
        [0x01, 0x06, 0x01, 0x10, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00,
         0xe2, 0xfc, 0x0f, 0xae, 0x66, 0x4d, 0x00, 0x00, 0x01, 0x00,
         0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc7, 0x00, 0x00,
         0x0f, 0xff, 0x00, 0x03, 0x82, 0xb0, 0xff, 0x6e, 0x51, 0x44,
         0x76, 0x65, 0x74, 0x68, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00,
         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00,
         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
         0x00, 0x01, 0x9e, 0x49, 0x7d, 0x7c, 0x06, 0x8d, 0x76, 0x65,
         0x74, 0x68, 0x32, 0x62, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
         0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00,
         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04,
         0x12, 0x13, 0xb4, 0x13, 0x4c, 0x19, 0x76, 0x65, 0x74, 0x68,
         0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
         0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x86, 0xbd,
         0xe3, 0xad, 0x3d, 0x73, 0x76, 0x65, 0x74, 0x68, 0x31, 0x62,
         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
         0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
         0x00, 0x00, 0x00, 0x00, 0xff, 0xfe, 0xe2, 0xfc, 0x0f, 0xae,
         0x66, 0x4d, 0x62, 0x72, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00,
         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
         0x00, 0x00].pack('C*')
      end

      When(:features_reply) { Pio::Features.read(features_reply_dump) }

      Then { features_reply.class == Pio::Features::Reply }
      Then { features_reply.ofp_version == 1 }
      Then do
        features_reply.message_type ==
          Pio::OpenFlow::Type::FEATURES_REPLY
      end
      Then { features_reply.message_length == 272 }
      Then { features_reply.transaction_id == 2 }
      Then { features_reply.xid == 2 }
      Then do
        pending 'TODO'
        !features_reply.body.empty?
      end
      Then { features_reply.datapath_id == 0xe2fc0fae664d }
      Then { features_reply.n_buffers == 0x100 }
      Then { features_reply.n_tables == 0xfe }
      Then do
        features_reply.capabilities ==
          [:flow_stats, :table_stats, :port_stats, :queue_stats, :arp_match_ip]
      end
      Then do
        features_reply.actions ==
          [:output, :set_vlan_vid, :set_vlan_pcp, :strip_vlan, :set_dl_src,
           :set_dl_dst, :set_nw_src, :set_nw_dst, :set_nw_tos, :set_tp_src,
           :set_tp_dst, :enqueue]
      end
      Then { features_reply.ports.size == 5 }
      Then { features_reply.ports.all? { |each| each.port_no > 0 } }
      Then do
        features_reply.ports.all? do |each|
          /^([0-9a-fA-F]{2}[:-]){5}[0-9a-fA-F]{2}$/i=~
            each.hardware_address.to_s
        end
      end
      Then do
        features_reply.ports.all? do |each|
          /^veth.*|^br0$/=~ each.name
        end
      end
      Then { features_reply.ports.all? { |each| each.config.empty? } }
      Then { features_reply.ports.all? { |each| each.state.empty? } }
      Then do
        features_reply.ports.all? do |port|
          port.curr.all? do |f|
            Pio::Type::OpenFlow::PortFeature.list.include?(f)
          end
        end
      end
      Then { features_reply.ports.all? { |each| each.advertised.empty? } }
      Then { features_reply.ports.all? { |each| each.supported.empty? } }
      Then { features_reply.ports.all? { |each| each.peer.empty? } }
    end

    context 'with a Hello message' do
      Given(:hello_dump) { [1, 0, 0, 8, 0, 0, 0, 0].pack('C*') }

      When(:result) { Pio::Features.read(hello_dump) }

      Then { result == Failure(Pio::ParseError) }
    end
  end
end
